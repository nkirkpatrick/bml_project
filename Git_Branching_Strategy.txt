# Django Git Branching Strategy for Azure Deployment

## Recommended Branching Strategy: Simplified GitFlow

### Branch Structure

```
main (production-ready)
├── develop (local development only)
├── feature/feature-name (individual features)
├── hotfix/issue-description (critical production fixes)
└── release/version-number (release preparation)
```

## Core Branches

### 1. `main` Branch
- **Purpose**: Production-ready code
- **Deployment**: Auto-deploys to Azure App Service (Production)
- **Protection**: Branch protection enabled, requires PR reviews
- **Merges from**: `release` branches and `hotfix` branches only

### 2. `develop` Branch
- **Purpose**: Local development integration on your Mac
- **Deployment**: Local development server only (no Azure deployment)
- **Merges from**: `feature` branches
- **Merges to**: `release` branches
- **Location**: Primarily exists on your local machine

## Supporting Branches

### Feature Branches
```bash
# Naming convention
feature/user-authentication
feature/payment-integration
feature/admin-dashboard

# Workflow
git checkout develop
git pull origin develop
git checkout -b feature/user-authentication
# ... make changes ...
git push origin feature/user-authentication
# Create Pull Request to develop
```

### Release Branches
```bash
# Naming convention
release/v1.2.0
release/v2.0.0-beta

# Workflow
git checkout develop
git pull origin develop
git checkout -b release/v1.2.0
# Update version numbers, final testing
git push origin release/v1.2.0
# PR to main when ready
```

### Hotfix Branches
```bash
# Naming convention
hotfix/critical-security-fix
hotfix/payment-bug

# Workflow
git checkout main
git pull origin main
git checkout -b hotfix/critical-security-fix
# ... fix the issue ...
git push origin hotfix/critical-security-fix
# PR to both main AND develop
```

## Azure Deployment Configuration

### Production Deployment Only

#### Production Deployment
```yaml
# .github/workflows/production-deploy.yml
name: Deploy to Production
on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          
      - name: Run tests
        run: |
          python manage.py test
          
      - name: Deploy to Azure App Service
        uses: azure/webapps-deploy@v2
        with:
          app-name: 'your-app-production'
          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE_PROD }}
```

### Optional: Testing Pipeline for Release Branches
```yaml
# .github/workflows/test-release.yml
name: Test Release Branch
on:
  push:
    branches: [release/*]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          
      - name: Run tests
        run: |
          python manage.py test
          
      - name: Run linting
        run: |
          flake8 .
          
      - name: Check migrations
        run: |
          python manage.py makemigrations --check --dry-run
```

### Environment-Specific Settings

#### settings/base.py
```python
# Base settings shared across environments
import os
from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent.parent

# Common settings
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    # ... your apps
]

# Database (overridden in environment-specific files)
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': os.environ.get('DB_NAME'),
        'USER': os.environ.get('DB_USER'),
        'PASSWORD': os.environ.get('DB_PASSWORD'),
        'HOST': os.environ.get('DB_HOST'),
        'PORT': os.environ.get('DB_PORT', '5432'),
        'OPTIONS': {
            'sslmode': 'require',
        },
    }
}
```

#### settings/development.py
```python
from .base import *

DEBUG = True
ALLOWED_HOSTS = ['localhost', '127.0.0.1', '0.0.0.0']

# Development-specific settings for local Mac development
EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'

# Less restrictive CORS for local development
CORS_ALLOW_ALL_ORIGINS = True

# Local database configuration
# Use SQLite for simple local development or PostgreSQL if preferred
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}

# Alternative: Local PostgreSQL on Mac
# DATABASES = {
#     'default': {
#         'ENGINE': 'django.db.backends.postgresql',
#         'NAME': 'myproject_local',
#         'USER': 'postgres',
#         'PASSWORD': 'localpassword',
#         'HOST': 'localhost',
#         'PORT': '5432',
#     }
# }

# Development logging
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
        },
    },
    'root': {
        'handlers': ['console'],
    },
    'loggers': {
        'django': {
            'handlers': ['console'],
            'level': 'INFO',
            'propagate': False,
        },
    },
}
```

#### settings/production.py
```python
from .base import *

DEBUG = False
ALLOWED_HOSTS = ['your-app.azurewebsites.net', 'yourdomain.com']

# Production security settings
SECURE_SSL_REDIRECT = True
SECURE_BROWSER_XSS_FILTER = True
SECURE_CONTENT_TYPE_NOSNIFF = True
SECURE_HSTS_SECONDS = 31536000
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True

# Production-specific settings
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = os.environ.get('EMAIL_HOST')
EMAIL_PORT = 587
EMAIL_USE_TLS = True
EMAIL_HOST_USER = os.environ.get('EMAIL_HOST_USER')
EMAIL_HOST_PASSWORD = os.environ.get('EMAIL_HOST_PASSWORD')

# Static files for production
STATIC_URL = '/static/'
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')

# Media files
MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
```

## Local Development Workflow on Mac

### Initial Setup
```bash
# Clone repository
git clone https://github.com/your-org/your-django-app.git
cd your-django-app

# Set up virtual environment on Mac
python3 -m venv venv
source venv/bin/activate

# Install dependencies
pip install -r requirements-dev.txt

# Set up local environment
cp .env.example .env
# Edit .env with local settings (SQLite or local PostgreSQL)

# Create and run migrations locally
python manage.py makemigrations
python manage.py migrate

# Create superuser for local development
python manage.py createsuperuser

# Start local development server
python manage.py runserver
```

### Daily Development Workflow on Mac
```bash
# 1. Start from develop branch (local)
git checkout develop
git pull origin develop  # If you occasionally push develop to GitHub

# 2. Create feature branch for new work
git checkout -b feature/new-awesome-feature

# 3. Develop locally on your Mac
python manage.py runserver  # Test locally
python manage.py test       # Run tests locally

# 4. Commit changes frequently (local commits)
git add .
git commit -m "Add user authentication logic"

# 5. When feature is complete, merge back to local develop
git checkout develop
git merge feature/new-awesome-feature

# 6. Create release branch when ready for production
git checkout -b release/v1.2.0

# 7. Push release branch to GitHub for review and deployment
git push origin release/v1.2.0
# Create Pull Request to main branch

# 8. Clean up local branches
git branch -d feature/new-awesome-feature
```

### Local Testing and Development
```bash
# Run Django development server
python manage.py runserver

# Run tests locally
python manage.py test

# Check for migration issues
python manage.py makemigrations --check
python manage.py migrate --plan

# Collect static files (if needed)
python manage.py collectstatic

# Create test data
python manage.py loaddata fixtures/sample_data.json

# Access local admin
# http://127.0.0.1:8000/admin/
```

## Environment Variables Configuration

### Local Development on Mac (.env file)
```bash
DJANGO_SETTINGS_MODULE=myproject.settings.development
DEBUG=True
SECRET_KEY=your-local-secret-key-for-mac-development

# Local database (if using PostgreSQL instead of SQLite)
# DB_NAME=myproject_local
# DB_USER=postgres
# DB_PASSWORD=localpassword
# DB_HOST=localhost
# DB_PORT=5432

# Local development email settings (optional)
EMAIL_HOST=localhost
EMAIL_PORT=1025  # For local SMTP testing with mailhog
```

### Azure App Service (Production Only)
```bash
DJANGO_SETTINGS_MODULE=myproject.settings.production
DEBUG=False
SECRET_KEY=your-production-secret-key
DB_NAME=myproject_prod
DB_USER=produser@myserver
DB_PASSWORD=secure-production-password
DB_HOST=myserver.postgres.database.azure.com
DB_PORT=5432

# Production email settings
EMAIL_HOST=smtp.sendgrid.net
EMAIL_PORT=587
EMAIL_USE_TLS=True
EMAIL_HOST_USER=apikey
EMAIL_HOST_PASSWORD=your-sendgrid-api-key
```

## Branch Protection Rules

### GitHub Branch Protection for `main`
```yaml
Settings → Branches → Add rule:
- Branch name pattern: main
- Require pull request reviews before merging: ✓
- Require status checks to pass before merging: ✓
  - Required checks: CI/CD pipeline, tests
- Require branches to be up to date before merging: ✓
- Require conversation resolution before merging: ✓
- Restrict pushes that create files larger than 100MB: ✓
- Allow force pushes: ✗
- Allow deletions: ✗
```

### GitHub Branch Protection for `develop`
```yaml
Settings → Branches → Add rule:
- Branch name pattern: develop
- Note: This branch exists primarily on your local Mac
- Consider making it optional since it's mainly for local development
- If you push develop to GitHub occasionally:
  - Require pull request reviews before merging: ✓ (optional)
  - Allow force pushes: ✓ (for local development flexibility)
```

## Release Process

### Standard Release Flow
```bash
# 1. Create release branch from develop
git checkout develop
git pull origin develop
git checkout -b release/v1.2.0

# 2. Update version numbers
# Update __init__.py, setup.py, etc.
echo "1.2.0" > VERSION

# 3. Final testing and bug fixes
# Only bug fixes, no new features

# 4. Create PR to main
# After review and approval, merge to main

# 5. Tag the release
git checkout main
git pull origin main
git tag -a v1.2.0 -m "Release version 1.2.0"
git push origin v1.2.0

# 6. Merge back to develop
git checkout develop
git merge main
git push origin develop

# 7. Clean up
git branch -d release/v1.2.0
```

## Hotfix Process

### Critical Production Fix
```bash
# 1. Create hotfix branch from main
git checkout main
git pull origin main
git checkout -b hotfix/critical-security-fix

# 2. Make the fix
# Make minimal changes to fix the issue

# 3. Test thoroughly
python manage.py test

# 4. Create PR to main (urgent review)
# Fast-track review process for critical fixes

# 5. After merge to main, also merge to develop
git checkout develop
git merge main
git push origin develop

# 6. Tag if necessary
git checkout main
git tag -a v1.2.1 -m "Hotfix version 1.2.1"
git push origin v1.2.1
```

## Best Practices

### Commit Messages
```bash
# Use conventional commits format
feat: add user authentication system
fix: resolve database connection timeout
docs: update API documentation
style: format code with black
refactor: optimize database queries
test: add unit tests for user model
chore: update dependencies
```

### Pull Request Template
```markdown
## Description
Brief description of changes

## Type of Change
- [ ] Bug fix
- [ ] New feature
- [ ] Breaking change
- [ ] Documentation update

## Testing
- [ ] Unit tests pass
- [ ] Integration tests pass
- [ ] Manual testing completed

## Checklist
- [ ] Code follows style guidelines
- [ ] Self-review completed
- [ ] Documentation updated
- [ ] No breaking changes (or properly documented)
```

### Code Review Guidelines
1. **Functionality**: Does the code work as intended?
2. **Security**: Are there any security vulnerabilities?
3. **Performance**: Are there any performance implications?
4. **Maintainability**: Is the code readable and maintainable?
5. **Testing**: Are there adequate tests?
6. **Documentation**: Is documentation updated?

## Troubleshooting Common Issues

### Merge Conflicts
```bash
# When pulling changes
git checkout feature/my-feature
git pull origin develop

# If conflicts occur
# 1. Resolve conflicts in your editor
# 2. Add resolved files
git add .
git commit -m "Resolve merge conflicts"

# Alternative: rebase (cleaner history)
git rebase develop
# Resolve conflicts, then
git rebase --continue
```

### Failed Deployments
```bash
# Check Azure deployment logs
az webapp log tail --resource-group myResourceGroup --name myApp

# Roll back if necessary using Azure portal
# Since there's only production deployment, ensure thorough local testing
```

### Local Development Issues on Mac
```bash
# Virtual environment issues
deactivate
rm -rf venv
python3 -m venv venv
source venv/bin/activate
pip install -r requirements-dev.txt

# Database issues (if using local PostgreSQL)
# Reset local database
dropdb myproject_local
createdb myproject_local
python manage.py migrate

# Port conflicts
# If port 8000 is in use
python manage.py runserver 8001

# Permission issues on Mac
sudo chown -R $(whoami) /path/to/your/project
```

### Database Migrations
```bash
# Always run migrations in order
python manage.py makemigrations
python manage.py migrate

# For production deployment
python manage.py migrate --settings=myproject.settings.production
```

This branching strategy provides a robust foundation for Django development with clear separation of environments and automated deployment to Azure.